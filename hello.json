{
    "version": 3,
    "deployment": {
        "manifest": {
            "time": "2022-03-02T09:39:57.36663+01:00",
            "magic": "49475b6ffce42f0b975c47d38c58de31b5c22dfe112d7e827e82f12b1235c8e8",
            "version": "v3.25.0"
        },
        "secrets_providers": {
            "type": "service",
            "state": {
                "url": "https://api.pulumi.com",
                "owner": "henriiik",
                "project": "dynamic-provider-bug",
                "stack": "dev"
            }
        },
        "resources": [
            {
                "urn": "urn:pulumi:dev::dynamic-provider-bug::pulumi:pulumi:Stack::dynamic-provider-bug-dev",
                "custom": false,
                "type": "pulumi:pulumi:Stack",
                "outputs": {
                    "Label": {}
                },
                "sequenceNumber": 1
            },
            {
                "urn": "urn:pulumi:dev::dynamic-provider-bug::pulumi:providers:pulumi-nodejs::default",
                "custom": true,
                "id": "7a325861-2010-49ad-92e0-c189973c8615",
                "type": "pulumi:providers:pulumi-nodejs",
                "sequenceNumber": 1
            },
            {
                "urn": "urn:pulumi:dev::dynamic-provider-bug::pulumi-nodejs:dynamic:Resource::my-label",
                "custom": true,
                "id": "123",
                "type": "pulumi-nodejs:dynamic:Resource",
                "inputs": {
                    "__provider": "exports.handler = __f0;\n\nObject.defineProperty(__f3, \"isInstance\", { configurable: true, writable: true, value: __f4 });\nvar __f5_prototype = {};\nObject.defineProperty(__f5_prototype, \"constructor\", { configurable: true, writable: true, value: __f5 });\nObject.defineProperty(__f5_prototype, \"get\", { configurable: true, writable: true, value: __f6 });\nObject.defineProperty(__f5_prototype, \"apply\", { configurable: true, writable: true, value: __f7 });\nObject.defineProperty(__f5, \"prototype\", { value: __f5_prototype });\nObject.defineProperty(__f5, \"create\", { configurable: true, writable: true, value: __f8 });\nObject.defineProperty(__f5, \"isInstance\", { configurable: true, writable: true, value: __f9 });\nObject.defineProperty(__f5, \"getPromisedValue\", { configurable: true, writable: true, value: __f10 });\nvar __pulumi = {secret: __secret};\nvar __provider = {create: __f1, delete: __f11};\n\nfunction __f2(__0, __1, __2, __3) {\n  return (function() {\n    with({  }) {\n\nreturn function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f3() {\n  return (function() {\n    with({  }) {\n\nreturn function /*constructor*/() {\n        /**\n         * A private field to help with RTTI that works in SxS scenarios.\n         *\n         * This is internal instead of being truly private, to support mixins and our serialization model.\n         * @internal\n         */\n        // eslint-disable-next-line @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match\n        this.__pulumiUnknown = true;\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f4(__0) {\n  return (function() {\n    with({ utils: require(\"@pulumi/pulumi/utils.js\") }) {\n\nreturn function /*isInstance*/(obj) {\n        return utils.isInstance(obj, \"__pulumiUnknown\");\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __isUnknown(__0) {\n  return (function() {\n    with({ Unknown: __f3, isUnknown: __isUnknown }) {\n\nreturn function /*isUnknown*/(val) {\n    return Unknown.isInstance(val);\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __createSimpleOutput(__0) {\n  return (function() {\n    with({ exports: require(\"@pulumi/pulumi/output.js\"), createSimpleOutput: __createSimpleOutput }) {\n\nreturn function /*createSimpleOutput*/(val) {\n    return new exports.Output(new Set(), val instanceof Promise ? val : Promise.resolve(val), \n    /*isKnown*/ Promise.resolve(true), \n    /*isSecret */ Promise.resolve(false), Promise.resolve(new Set()));\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __getAllResources(__0) {\n  return (function() {\n    with({ getAllResources: __getAllResources }) {\n\nreturn function /*getAllResources*/(op) {\n    return op.allResources instanceof Function\n        ? op.allResources()\n        : Promise.resolve(op.resources());\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __copyResources(__0) {\n  return (function() {\n    with({ copyResources: __copyResources }) {\n\nreturn function /*copyResources*/(resources) {\n    const copy = Array.isArray(resources) ? new Set(resources) :\n        resources instanceof Set ? new Set(resources) :\n            new Set([resources]);\n    return copy;\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __containsUnknowns(__0) {\n  return (function() {\n    with({ isUnknown: __isUnknown, containsUnknowns: __containsUnknowns }) {\n\nreturn function /*containsUnknowns*/(value) {\n    return impl(value, new Set());\n    function impl(val, seen) {\n        if (val === null || typeof val !== \"object\") {\n            return false;\n        }\n        else if (isUnknown(val)) {\n            return true;\n        }\n        else if (seen.has(val)) {\n            return false;\n        }\n        seen.add(val);\n        if (val instanceof Array) {\n            return val.some(e =\u003e impl(e, seen));\n        }\n        else {\n            return Object.keys(val).some(k =\u003e impl(val[k], seen));\n        }\n    }\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __liftInnerOutput(__0, __1, __2, __3) {\n  return (function() {\n    with({ __awaiter: __f2, exports: require(\"@pulumi/pulumi/output.js\"), getAllResources: __getAllResources, utils: require(\"@pulumi/pulumi/utils.js\"), liftInnerOutput: __liftInnerOutput }) {\n\nreturn function /*liftInnerOutput*/(allResources, value, isKnown, isSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!exports.Output.isInstance(value)) {\n            // 'value' itself wasn't an output, no need to transform any of the data we got.\n            return { allResources, value, isKnown, isSecret };\n        }\n        // 'value' was an Output.  So we unwrap that to get the inner value/isKnown/isSecret/resources\n        // returned by that Output and merge with the state passed in to get the state of the final Output.\n        // Note: we intentionally await all the promises of the inner output. This way we properly\n        // propagate any rejections of any of these promises through the outer output as well.\n        const innerValue = yield value.promise(/*withUnknowns*/ true);\n        const innerIsKnown = yield value.isKnown;\n        const innerIsSecret = yield (value.isSecret || Promise.resolve(false));\n        // If we're working with a new-style output, grab all its resources and merge into ours.\n        // Otherwise, if this is an old-style output, just grab the resources it was known to have\n        // at construction time.\n        const innerResources = yield getAllResources(value);\n        const totalResources = utils.union(allResources, innerResources);\n        return {\n            allResources: totalResources,\n            value: innerValue,\n            isKnown: innerIsKnown,\n            isSecret: isSecret || innerIsSecret,\n        };\n    });\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f5(__0, __1, __2, __3, __4) {\n  return (function() {\n    with({ copyResources: __copyResources, utils: require(\"@pulumi/pulumi/utils.js\"), containsUnknowns: __containsUnknowns, liftInnerOutput: __liftInnerOutput, OutputImpl: __f5, isUnknown: __isUnknown, exports: require(\"@pulumi/pulumi/output.js\") }) {\n\nreturn function /*constructor*/(resources, promise, isKnown, isSecret, allResources) {\n        /**\n         * A private field to help with RTTI that works in SxS scenarios.\n         *\n         * This is internal instead of being truly private, to support mixins and our serialization model.\n         * @internal\n         */\n        // eslint-disable-next-line @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match\n        this.__pulumiOutput = true;\n        // Always create a copy so that no one accidentally modifies our Resource list.\n        const resourcesCopy = copyResources(resources);\n        // Create a copy of the async resources.  Populate this with the sync-resources if that's\n        // all we have.  That way this is always ensured to be a superset of the list of sync resources.\n        allResources = allResources || Promise.resolve([]);\n        const allResourcesCopy = allResources.then(r =\u003e utils.union(copyResources(r), resourcesCopy));\n        // We are only known if we are not explicitly unknown and the resolved value of the output\n        // contains no distinguished unknown values.\n        isKnown = Promise.all([isKnown, promise]).then(([known, val]) =\u003e known \u0026\u0026 !containsUnknowns(val));\n        const lifted = Promise.all([allResourcesCopy, promise, isKnown, isSecret])\n            .then(([liftedResources, value, liftedIsKnown, liftedIsSecret]) =\u003e liftInnerOutput(liftedResources, value, liftedIsKnown, liftedIsSecret));\n        this.resources = () =\u003e resourcesCopy;\n        this.allResources = () =\u003e lifted.then(l =\u003e l.allResources);\n        this.isKnown = lifted.then(l =\u003e l.isKnown);\n        this.isSecret = lifted.then(l =\u003e l.isSecret);\n        this.promise = (withUnknowns) =\u003e OutputImpl.getPromisedValue(lifted.then(l =\u003e l.value), withUnknowns);\n        this.toString = () =\u003e {\n            const message = `Calling [toString] on an [Output\u003cT\u003e] is not supported.\n\nTo get the value of an Output\u003cT\u003e as an Output\u003cstring\u003e consider either:\n1: o.apply(v =\u003e \\`prefix\\${v}suffix\\`)\n2: pulumi.interpolate \\`prefix\\${v}suffix\\`\n\nSee https://pulumi.io/help/outputs for more details.\nThis function may throw in a future version of @pulumi/pulumi.`;\n            return message;\n        };\n        this.toJSON = () =\u003e {\n            const message = `Calling [toJSON] on an [Output\u003cT\u003e] is not supported.\n\nTo get the value of an Output as a JSON value or JSON string consider either:\n    1: o.apply(v =\u003e v.toJSON())\n    2: o.apply(v =\u003e JSON.stringify(v))\n\nSee https://pulumi.io/help/outputs for more details.\nThis function may throw in a future version of @pulumi/pulumi.`;\n            return message;\n        };\n        return new Proxy(this, {\n            get: (obj, prop) =\u003e {\n                // Recreate the prototype walk to ensure we find any actual members defined directly\n                // on `Output\u003cT\u003e`.\n                for (let o = obj; o; o = Object.getPrototypeOf(o)) {\n                    if (o.hasOwnProperty(prop)) {\n                        return o[prop];\n                    }\n                }\n                // Always explicitly fail on a member called 'then'.  It is used by other systems to\n                // determine if this is a Promise, and we do not want to indicate that that's what\n                // we are.\n                if (prop === \"then\") {\n                    return undefined;\n                }\n                // Do not lift members that start with __.  Technically, if all libraries were\n                // using this version of pulumi/pulumi we would not need this.  However, this is\n                // so that downstream consumers can use this version of pulumi/pulumi while also\n                // passing these new Outputs to older versions of pulumi/pulumi.  The reason this\n                // can be a problem is that older versions do an RTTI check that simply asks questions\n                // like:\n                //\n                //      Is there a member on this object called '__pulumiResource'\n                //\n                // If we automatically lift such a member (even if it eventually points to 'undefined'),\n                // then those RTTI checks will succeed.\n                //\n                // Note: this should be safe to not lift as, in general, properties with this prefix\n                // are not at all common (and in general are used to represent private things anyway\n                // that likely should not be exposed).\n                //\n                // Similarly, do not respond to the 'doNotCapture' member name.  It serves a similar\n                // RTTI purpose.\n                if (typeof prop === \"string\") {\n                    if (prop.startsWith(\"__\") || prop === \"doNotCapture\" || prop === \"deploymentOnlyModule\") {\n                        return undefined;\n                    }\n                }\n                // Fail out if we are being accessed using a symbol.  Many APIs will access with a\n                // well known symbol (like 'Symbol.toPrimitive') to check for the presence of something.\n                // They will only check for the existence of that member, and we don't want to make it\n                // appear that have those.\n                //\n                // Another way of putting this is that we only forward 'string/number' members to our\n                // underlying value.\n                if (typeof prop === \"symbol\") {\n                    return undefined;\n                }\n                // Else for *any other* property lookup, succeed the lookup and return a lifted\n                // `apply` on the underlying `Output`.\n                return obj.apply((ob) =\u003e {\n                    if (ob === undefined || ob === null) {\n                        return undefined;\n                    }\n                    else if (isUnknown(ob)) {\n                        // If the value of this output is unknown, the result of the access should also be unknown.\n                        // This is conceptually consistent, and also prevents us from returning a \"known undefined\"\n                        // value from the `ob[prop]` expression below.\n                        return exports.unknown;\n                    }\n                    return ob[prop];\n                }, /*runWithUnknowns:*/ true);\n            },\n        });\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f6() {\n  return (function() {\n    with({  }) {\n\nreturn function /*get*/() {\n        throw new Error(`Cannot call '.get' during update or preview.\nTo manipulate the value of this Output, use '.apply' instead.`);\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __applyHelperAsync(__0, __1, __2, __3, __4, __5) {\n  return (function() {\n    with({ __awaiter: __f2, runtime: require(\"@pulumi/pulumi/runtime/index.js\"), containsUnknowns: __containsUnknowns, exports: require(\"@pulumi/pulumi/output.js\"), liftInnerOutput: __liftInnerOutput, applyHelperAsync: __applyHelperAsync }) {\n\nreturn function /*applyHelperAsync*/(allResources, value, isKnown, isSecret, func, runWithUnknowns) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (runtime.isDryRun()) {\n            // During previews only perform the apply if the engine was able to give us an actual value\n            // for this Output.\n            const applyDuringPreview = isKnown || runWithUnknowns;\n            if (!applyDuringPreview) {\n                // We didn't actually run the function, our new Output is definitely **not** known.\n                return {\n                    allResources,\n                    value: undefined,\n                    isKnown: false,\n                    isSecret,\n                };\n            }\n            // If we are running with unknown values and the value is explicitly unknown but does not actually\n            // contain any unknown values, collapse its value to the unknown value. This ensures that callbacks\n            // that expect to see unknowns during preview in outputs that are not known will always do so.\n            if (!isKnown \u0026\u0026 runWithUnknowns \u0026\u0026 !containsUnknowns(value)) {\n                value = exports.unknown;\n            }\n        }\n        const transformed = yield func(value);\n        // We successfully ran the inner function. Our new Output should be considered known.  We\n        // preserve secretness from our original Output to the new one we're creating.\n        return liftInnerOutput(allResources, transformed, /*isKnown*/ true, isSecret);\n    });\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f7(__0, __1) {\n  return (function() {\n    with({ applyHelperAsync: __applyHelperAsync, OutputImpl: __f5 }) {\n\nreturn function /*apply*/(func, runWithUnknowns) {\n        // we're inside the modern `output` code, so it's safe to call `.allResources!` here.\n        const applied = Promise.all([this.allResources(), this.promise(/*withUnknowns*/ true), this.isKnown, this.isSecret])\n            .then(([allResources, value, isKnown, isSecret]) =\u003e applyHelperAsync(allResources, value, isKnown, isSecret, func, !!runWithUnknowns));\n        const result = new OutputImpl(this.resources(), applied.then(a =\u003e a.value), applied.then(a =\u003e a.isKnown), applied.then(a =\u003e a.isSecret), applied.then(a =\u003e a.allResources));\n        return result;\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f8(__0) {\n  return (function() {\n    with({ output: __output }) {\n\nreturn function /*create*/(val) {\n        return output(val);\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f9(__0) {\n  return (function() {\n    with({ utils: require(\"@pulumi/pulumi/utils.js\") }) {\n\nreturn function /*isInstance*/(obj) {\n        return utils.isInstance(obj, \"__pulumiOutput\");\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f10(__0, __1) {\n  return (function() {\n    with({ __awaiter: __f2, containsUnknowns: __containsUnknowns }) {\n\nreturn function /*getPromisedValue*/(promise, withUnknowns) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If the caller did not explicitly ask to see unknown values and val contains unknowns, return undefined. This\n            // preserves compatibility with earlier versions of the Pulumi SDK.\n            const val = yield promise;\n            if (!withUnknowns \u0026\u0026 containsUnknowns(val)) {\n                return undefined;\n            }\n            return val;\n        });\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __getAwaitableValue(__0) {\n  return (function() {\n    with({ exports: require(\"@pulumi/pulumi/output.js\"), getAwaitableValue: __getAwaitableValue }) {\n\nreturn function /*getAwaitableValue*/(v) {\n    if (exports.Output.isInstance(v)) {\n        return v.promise(/* withUnknowns */ true);\n    }\n    else {\n        return v;\n    }\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __isSecret(__0) {\n  return (function() {\n    with({ exports: require(\"@pulumi/pulumi/output.js\"), isSecret: __isSecret }) {\n\nreturn function /*isSecret*/(val) {\n    return exports.Output.isInstance(val.isSecret) ? Promise.resolve(false) : val.isSecret;\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __isSecretOutput(__0) {\n  return (function() {\n    with({ isSecret: __isSecret, isSecretOutput: __isSecretOutput }) {\n\nreturn function /*isSecretOutput*/(o) {\n    return isSecret(o);\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __getResourcesAndDetails(__0) {\n  return (function() {\n    with({ exports: require(\"@pulumi/pulumi/output.js\"), isSecretOutput: __isSecretOutput, getResourcesAndDetails: __getResourcesAndDetails }) {\n\nreturn function /*getResourcesAndDetails*/(allValues) {\n    const syncResources = new Set();\n    const allOutputs = [];\n    for (const v of allValues) {\n        if (exports.Output.isInstance(v)) {\n            allOutputs.push(v);\n            for (const res of v.resources()) {\n                syncResources.add(res);\n            }\n        }\n    }\n    // All the outputs were generated in `function all` using `output(v)`.  So it's safe\n    // to call `.allResources!` here.\n    const allResources = Promise.all(allOutputs.map(o =\u003e o.allResources())).then(arr =\u003e {\n        const result = new Set();\n        for (const set of arr) {\n            for (const res of set) {\n                result.add(res);\n            }\n        }\n        return result;\n    });\n    // A merged output is known if all of its inputs are known.\n    const isKnown = Promise.all(allOutputs.map(o =\u003e o.isKnown)).then(ps =\u003e ps.every(b =\u003e b));\n    // A merged output is secret if any of its inputs are secret.\n    const isSecret = Promise.all(allOutputs.map(o =\u003e isSecretOutput(o))).then(ps =\u003e ps.some(b =\u003e b));\n    return [syncResources, isKnown, isSecret, allResources];\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __getPromisedObject(__0) {\n  return (function() {\n    with({ __awaiter: __f2, getAwaitableValue: __getAwaitableValue, getPromisedObject: __getPromisedObject }) {\n\nreturn function /*getPromisedObject*/(keysAndOutputs) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = {};\n        for (const kvp of keysAndOutputs) {\n            result[kvp.key] = yield getAwaitableValue(kvp.value);\n        }\n        return result;\n    });\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __outputRec(__0) {\n  return (function() {\n    with({ resource_1: require(\"@pulumi/pulumi/resource.js\"), isUnknown: __isUnknown, createSimpleOutput: __createSimpleOutput, exports: require(\"@pulumi/pulumi/output.js\"), getAllResources: __getAllResources, OutputImpl: __f5, getAwaitableValue: __getAwaitableValue, getResourcesAndDetails: __getResourcesAndDetails, getPromisedObject: __getPromisedObject, outputRec: __outputRec }) {\n\nreturn function /*outputRec*/(val) {\n    if (val === null || typeof val !== \"object\") {\n        // strings, numbers, booleans, functions, symbols, undefineds, nulls are all returned as\n        // themselves.  They are always 'known' (i.e. we can safely 'apply' off of them even during\n        // preview).\n        return val;\n    }\n    else if (resource_1.Resource.isInstance(val)) {\n        // Don't unwrap Resources, there are existing codepaths that return Resources through\n        // Outputs and we want to preserve them as is when flattening.\n        return val;\n    }\n    else if (isUnknown(val)) {\n        return val;\n    }\n    else if (val instanceof Promise) {\n        // Recurse into the value the Promise points to.  This may end up producing a\n        // Promise\u003cOutput\u003e. Wrap this in another Output as the final result.  This Output's\n        // construction will be able to merge the inner Output's data with its own.  See\n        // liftInnerOutput for more details.\n        return createSimpleOutput(val.then(v =\u003e outputRec(v)));\n    }\n    else if (exports.Output.isInstance(val)) {\n        // We create a new output here from the raw pieces of the original output in order to\n        // accommodate outputs from downlevel SxS SDKs.  This ensures that within this package it is\n        // safe to assume the implementation of any Output returned by the `output` function.\n        //\n        // This includes:\n        // 1. that first-class unknowns are properly represented in the system: if this was a\n        //    downlevel output where val.isKnown resolves to false, this guarantees that the\n        //    returned output's promise resolves to unknown.\n        // 2. That the `isSecret` property is available.\n        // 3. That the `.allResources` is available.\n        const allResources = getAllResources(val);\n        const newOutput = new OutputImpl(val.resources(), val.promise(/*withUnknowns*/ true), val.isKnown, val.isSecret, allResources);\n        return newOutput.apply(outputRec, /*runWithUnknowns*/ true);\n    }\n    else if (val instanceof Array) {\n        const allValues = [];\n        let hasOutputs = false;\n        for (const v of val) {\n            const ev = outputRec(v);\n            allValues.push(ev);\n            if (exports.Output.isInstance(ev)) {\n                hasOutputs = true;\n            }\n        }\n        // If we didn't encounter any nested Outputs, we don't need to do anything.  We can just\n        // return this value as is.\n        if (!hasOutputs) {\n            // Note: we intentionally return 'allValues' here and not 'val'.  This ensures we get a\n            // copy.  This has been behavior we've had since the beginning and there may be subtle\n            // logic out there that depends on this that we would not want ot break.\n            return allValues;\n        }\n        // Otherwise, combine the data from all the outputs/non-outputs to one final output.\n        const promisedArray = Promise.all(allValues.map(v =\u003e getAwaitableValue(v)));\n        const [syncResources, isKnown, isSecret, allResources] = getResourcesAndDetails(allValues);\n        return new exports.Output(syncResources, promisedArray, isKnown, isSecret, allResources);\n    }\n    else {\n        const promisedValues = [];\n        let hasOutputs = false;\n        for (const k of Object.keys(val)) {\n            const ev = outputRec(val[k]);\n            promisedValues.push({ key: k, value: ev });\n            if (exports.Output.isInstance(ev)) {\n                hasOutputs = true;\n            }\n        }\n        if (!hasOutputs) {\n            // Note: we intentionally return a new value here and not 'val'.  This ensures we get a\n            // copy.  This has been behavior we've had since the beginning and there may be subtle\n            // logic out there that depends on this that we would not want ot break.\n            return promisedValues.reduce((o, kvp) =\u003e { o[kvp.key] = kvp.value; return o; }, {});\n        }\n        const promisedObject = getPromisedObject(promisedValues);\n        const [syncResources, isKnown, isSecret, allResources] = getResourcesAndDetails(promisedValues.map(kvp =\u003e kvp.value));\n        return new exports.Output(syncResources, promisedObject, isKnown, isSecret, allResources);\n    }\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __output(__0) {\n  return (function() {\n    with({ outputRec: __outputRec, exports: require(\"@pulumi/pulumi/output.js\"), createSimpleOutput: __createSimpleOutput, output: __output }) {\n\nreturn function /*output*/(val) {\n    const ov = outputRec(val);\n    return exports.Output.isInstance(ov) ? ov : createSimpleOutput(ov);\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __secret(__0) {\n  return (function() {\n    with({ output: __output, exports: require(\"@pulumi/pulumi/output.js\"), secret: __secret }) {\n\nreturn function /*secret*/(val) {\n    const o = output(val);\n    // we called `output` right above this, so it's safe to call `.allResources` on the result.\n    return new exports.Output(o.resources(), o.promise(/*withUnknowns*/ true), o.isKnown, Promise.resolve(true), o.allResources());\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f1(__0) {\n  return (function() {\n    with({ __awaiter: __f2, assert: require(\"assert\"), pulumi: __pulumi }) {\n\nreturn function /*create*/(inputs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(Object.keys(inputs));\n            assert(inputs.owner);\n            return { id: \"123\", outs: { lol: pulumi.secret(inputs.owner) } };\n        });\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f11(__0, __1) {\n  return (function() {\n    with({ __awaiter: __f2, assert: require(\"assert\") }) {\n\nreturn function /*delete*/(id, props) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(Object.keys(props));\n            assert(props.owner);\n        });\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f0() {\n  return (function() {\n    with({ provider: __provider }) {\n\nreturn () =\u003e provider;\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n",
                    "owner": "me"
                },
                "outputs": {
                    "__provider": "exports.handler = __f0;\n\nObject.defineProperty(__f3, \"isInstance\", { configurable: true, writable: true, value: __f4 });\nvar __f5_prototype = {};\nObject.defineProperty(__f5_prototype, \"constructor\", { configurable: true, writable: true, value: __f5 });\nObject.defineProperty(__f5_prototype, \"get\", { configurable: true, writable: true, value: __f6 });\nObject.defineProperty(__f5_prototype, \"apply\", { configurable: true, writable: true, value: __f7 });\nObject.defineProperty(__f5, \"prototype\", { value: __f5_prototype });\nObject.defineProperty(__f5, \"create\", { configurable: true, writable: true, value: __f8 });\nObject.defineProperty(__f5, \"isInstance\", { configurable: true, writable: true, value: __f9 });\nObject.defineProperty(__f5, \"getPromisedValue\", { configurable: true, writable: true, value: __f10 });\nvar __pulumi = {secret: __secret};\nvar __provider = {create: __f1, delete: __f11};\n\nfunction __f2(__0, __1, __2, __3) {\n  return (function() {\n    with({  }) {\n\nreturn function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f3() {\n  return (function() {\n    with({  }) {\n\nreturn function /*constructor*/() {\n        /**\n         * A private field to help with RTTI that works in SxS scenarios.\n         *\n         * This is internal instead of being truly private, to support mixins and our serialization model.\n         * @internal\n         */\n        // eslint-disable-next-line @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match\n        this.__pulumiUnknown = true;\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f4(__0) {\n  return (function() {\n    with({ utils: require(\"@pulumi/pulumi/utils.js\") }) {\n\nreturn function /*isInstance*/(obj) {\n        return utils.isInstance(obj, \"__pulumiUnknown\");\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __isUnknown(__0) {\n  return (function() {\n    with({ Unknown: __f3, isUnknown: __isUnknown }) {\n\nreturn function /*isUnknown*/(val) {\n    return Unknown.isInstance(val);\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __createSimpleOutput(__0) {\n  return (function() {\n    with({ exports: require(\"@pulumi/pulumi/output.js\"), createSimpleOutput: __createSimpleOutput }) {\n\nreturn function /*createSimpleOutput*/(val) {\n    return new exports.Output(new Set(), val instanceof Promise ? val : Promise.resolve(val), \n    /*isKnown*/ Promise.resolve(true), \n    /*isSecret */ Promise.resolve(false), Promise.resolve(new Set()));\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __getAllResources(__0) {\n  return (function() {\n    with({ getAllResources: __getAllResources }) {\n\nreturn function /*getAllResources*/(op) {\n    return op.allResources instanceof Function\n        ? op.allResources()\n        : Promise.resolve(op.resources());\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __copyResources(__0) {\n  return (function() {\n    with({ copyResources: __copyResources }) {\n\nreturn function /*copyResources*/(resources) {\n    const copy = Array.isArray(resources) ? new Set(resources) :\n        resources instanceof Set ? new Set(resources) :\n            new Set([resources]);\n    return copy;\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __containsUnknowns(__0) {\n  return (function() {\n    with({ isUnknown: __isUnknown, containsUnknowns: __containsUnknowns }) {\n\nreturn function /*containsUnknowns*/(value) {\n    return impl(value, new Set());\n    function impl(val, seen) {\n        if (val === null || typeof val !== \"object\") {\n            return false;\n        }\n        else if (isUnknown(val)) {\n            return true;\n        }\n        else if (seen.has(val)) {\n            return false;\n        }\n        seen.add(val);\n        if (val instanceof Array) {\n            return val.some(e =\u003e impl(e, seen));\n        }\n        else {\n            return Object.keys(val).some(k =\u003e impl(val[k], seen));\n        }\n    }\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __liftInnerOutput(__0, __1, __2, __3) {\n  return (function() {\n    with({ __awaiter: __f2, exports: require(\"@pulumi/pulumi/output.js\"), getAllResources: __getAllResources, utils: require(\"@pulumi/pulumi/utils.js\"), liftInnerOutput: __liftInnerOutput }) {\n\nreturn function /*liftInnerOutput*/(allResources, value, isKnown, isSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!exports.Output.isInstance(value)) {\n            // 'value' itself wasn't an output, no need to transform any of the data we got.\n            return { allResources, value, isKnown, isSecret };\n        }\n        // 'value' was an Output.  So we unwrap that to get the inner value/isKnown/isSecret/resources\n        // returned by that Output and merge with the state passed in to get the state of the final Output.\n        // Note: we intentionally await all the promises of the inner output. This way we properly\n        // propagate any rejections of any of these promises through the outer output as well.\n        const innerValue = yield value.promise(/*withUnknowns*/ true);\n        const innerIsKnown = yield value.isKnown;\n        const innerIsSecret = yield (value.isSecret || Promise.resolve(false));\n        // If we're working with a new-style output, grab all its resources and merge into ours.\n        // Otherwise, if this is an old-style output, just grab the resources it was known to have\n        // at construction time.\n        const innerResources = yield getAllResources(value);\n        const totalResources = utils.union(allResources, innerResources);\n        return {\n            allResources: totalResources,\n            value: innerValue,\n            isKnown: innerIsKnown,\n            isSecret: isSecret || innerIsSecret,\n        };\n    });\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f5(__0, __1, __2, __3, __4) {\n  return (function() {\n    with({ copyResources: __copyResources, utils: require(\"@pulumi/pulumi/utils.js\"), containsUnknowns: __containsUnknowns, liftInnerOutput: __liftInnerOutput, OutputImpl: __f5, isUnknown: __isUnknown, exports: require(\"@pulumi/pulumi/output.js\") }) {\n\nreturn function /*constructor*/(resources, promise, isKnown, isSecret, allResources) {\n        /**\n         * A private field to help with RTTI that works in SxS scenarios.\n         *\n         * This is internal instead of being truly private, to support mixins and our serialization model.\n         * @internal\n         */\n        // eslint-disable-next-line @typescript-eslint/naming-convention,no-underscore-dangle,id-blacklist,id-match\n        this.__pulumiOutput = true;\n        // Always create a copy so that no one accidentally modifies our Resource list.\n        const resourcesCopy = copyResources(resources);\n        // Create a copy of the async resources.  Populate this with the sync-resources if that's\n        // all we have.  That way this is always ensured to be a superset of the list of sync resources.\n        allResources = allResources || Promise.resolve([]);\n        const allResourcesCopy = allResources.then(r =\u003e utils.union(copyResources(r), resourcesCopy));\n        // We are only known if we are not explicitly unknown and the resolved value of the output\n        // contains no distinguished unknown values.\n        isKnown = Promise.all([isKnown, promise]).then(([known, val]) =\u003e known \u0026\u0026 !containsUnknowns(val));\n        const lifted = Promise.all([allResourcesCopy, promise, isKnown, isSecret])\n            .then(([liftedResources, value, liftedIsKnown, liftedIsSecret]) =\u003e liftInnerOutput(liftedResources, value, liftedIsKnown, liftedIsSecret));\n        this.resources = () =\u003e resourcesCopy;\n        this.allResources = () =\u003e lifted.then(l =\u003e l.allResources);\n        this.isKnown = lifted.then(l =\u003e l.isKnown);\n        this.isSecret = lifted.then(l =\u003e l.isSecret);\n        this.promise = (withUnknowns) =\u003e OutputImpl.getPromisedValue(lifted.then(l =\u003e l.value), withUnknowns);\n        this.toString = () =\u003e {\n            const message = `Calling [toString] on an [Output\u003cT\u003e] is not supported.\n\nTo get the value of an Output\u003cT\u003e as an Output\u003cstring\u003e consider either:\n1: o.apply(v =\u003e \\`prefix\\${v}suffix\\`)\n2: pulumi.interpolate \\`prefix\\${v}suffix\\`\n\nSee https://pulumi.io/help/outputs for more details.\nThis function may throw in a future version of @pulumi/pulumi.`;\n            return message;\n        };\n        this.toJSON = () =\u003e {\n            const message = `Calling [toJSON] on an [Output\u003cT\u003e] is not supported.\n\nTo get the value of an Output as a JSON value or JSON string consider either:\n    1: o.apply(v =\u003e v.toJSON())\n    2: o.apply(v =\u003e JSON.stringify(v))\n\nSee https://pulumi.io/help/outputs for more details.\nThis function may throw in a future version of @pulumi/pulumi.`;\n            return message;\n        };\n        return new Proxy(this, {\n            get: (obj, prop) =\u003e {\n                // Recreate the prototype walk to ensure we find any actual members defined directly\n                // on `Output\u003cT\u003e`.\n                for (let o = obj; o; o = Object.getPrototypeOf(o)) {\n                    if (o.hasOwnProperty(prop)) {\n                        return o[prop];\n                    }\n                }\n                // Always explicitly fail on a member called 'then'.  It is used by other systems to\n                // determine if this is a Promise, and we do not want to indicate that that's what\n                // we are.\n                if (prop === \"then\") {\n                    return undefined;\n                }\n                // Do not lift members that start with __.  Technically, if all libraries were\n                // using this version of pulumi/pulumi we would not need this.  However, this is\n                // so that downstream consumers can use this version of pulumi/pulumi while also\n                // passing these new Outputs to older versions of pulumi/pulumi.  The reason this\n                // can be a problem is that older versions do an RTTI check that simply asks questions\n                // like:\n                //\n                //      Is there a member on this object called '__pulumiResource'\n                //\n                // If we automatically lift such a member (even if it eventually points to 'undefined'),\n                // then those RTTI checks will succeed.\n                //\n                // Note: this should be safe to not lift as, in general, properties with this prefix\n                // are not at all common (and in general are used to represent private things anyway\n                // that likely should not be exposed).\n                //\n                // Similarly, do not respond to the 'doNotCapture' member name.  It serves a similar\n                // RTTI purpose.\n                if (typeof prop === \"string\") {\n                    if (prop.startsWith(\"__\") || prop === \"doNotCapture\" || prop === \"deploymentOnlyModule\") {\n                        return undefined;\n                    }\n                }\n                // Fail out if we are being accessed using a symbol.  Many APIs will access with a\n                // well known symbol (like 'Symbol.toPrimitive') to check for the presence of something.\n                // They will only check for the existence of that member, and we don't want to make it\n                // appear that have those.\n                //\n                // Another way of putting this is that we only forward 'string/number' members to our\n                // underlying value.\n                if (typeof prop === \"symbol\") {\n                    return undefined;\n                }\n                // Else for *any other* property lookup, succeed the lookup and return a lifted\n                // `apply` on the underlying `Output`.\n                return obj.apply((ob) =\u003e {\n                    if (ob === undefined || ob === null) {\n                        return undefined;\n                    }\n                    else if (isUnknown(ob)) {\n                        // If the value of this output is unknown, the result of the access should also be unknown.\n                        // This is conceptually consistent, and also prevents us from returning a \"known undefined\"\n                        // value from the `ob[prop]` expression below.\n                        return exports.unknown;\n                    }\n                    return ob[prop];\n                }, /*runWithUnknowns:*/ true);\n            },\n        });\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f6() {\n  return (function() {\n    with({  }) {\n\nreturn function /*get*/() {\n        throw new Error(`Cannot call '.get' during update or preview.\nTo manipulate the value of this Output, use '.apply' instead.`);\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __applyHelperAsync(__0, __1, __2, __3, __4, __5) {\n  return (function() {\n    with({ __awaiter: __f2, runtime: require(\"@pulumi/pulumi/runtime/index.js\"), containsUnknowns: __containsUnknowns, exports: require(\"@pulumi/pulumi/output.js\"), liftInnerOutput: __liftInnerOutput, applyHelperAsync: __applyHelperAsync }) {\n\nreturn function /*applyHelperAsync*/(allResources, value, isKnown, isSecret, func, runWithUnknowns) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (runtime.isDryRun()) {\n            // During previews only perform the apply if the engine was able to give us an actual value\n            // for this Output.\n            const applyDuringPreview = isKnown || runWithUnknowns;\n            if (!applyDuringPreview) {\n                // We didn't actually run the function, our new Output is definitely **not** known.\n                return {\n                    allResources,\n                    value: undefined,\n                    isKnown: false,\n                    isSecret,\n                };\n            }\n            // If we are running with unknown values and the value is explicitly unknown but does not actually\n            // contain any unknown values, collapse its value to the unknown value. This ensures that callbacks\n            // that expect to see unknowns during preview in outputs that are not known will always do so.\n            if (!isKnown \u0026\u0026 runWithUnknowns \u0026\u0026 !containsUnknowns(value)) {\n                value = exports.unknown;\n            }\n        }\n        const transformed = yield func(value);\n        // We successfully ran the inner function. Our new Output should be considered known.  We\n        // preserve secretness from our original Output to the new one we're creating.\n        return liftInnerOutput(allResources, transformed, /*isKnown*/ true, isSecret);\n    });\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f7(__0, __1) {\n  return (function() {\n    with({ applyHelperAsync: __applyHelperAsync, OutputImpl: __f5 }) {\n\nreturn function /*apply*/(func, runWithUnknowns) {\n        // we're inside the modern `output` code, so it's safe to call `.allResources!` here.\n        const applied = Promise.all([this.allResources(), this.promise(/*withUnknowns*/ true), this.isKnown, this.isSecret])\n            .then(([allResources, value, isKnown, isSecret]) =\u003e applyHelperAsync(allResources, value, isKnown, isSecret, func, !!runWithUnknowns));\n        const result = new OutputImpl(this.resources(), applied.then(a =\u003e a.value), applied.then(a =\u003e a.isKnown), applied.then(a =\u003e a.isSecret), applied.then(a =\u003e a.allResources));\n        return result;\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f8(__0) {\n  return (function() {\n    with({ output: __output }) {\n\nreturn function /*create*/(val) {\n        return output(val);\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f9(__0) {\n  return (function() {\n    with({ utils: require(\"@pulumi/pulumi/utils.js\") }) {\n\nreturn function /*isInstance*/(obj) {\n        return utils.isInstance(obj, \"__pulumiOutput\");\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f10(__0, __1) {\n  return (function() {\n    with({ __awaiter: __f2, containsUnknowns: __containsUnknowns }) {\n\nreturn function /*getPromisedValue*/(promise, withUnknowns) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // If the caller did not explicitly ask to see unknown values and val contains unknowns, return undefined. This\n            // preserves compatibility with earlier versions of the Pulumi SDK.\n            const val = yield promise;\n            if (!withUnknowns \u0026\u0026 containsUnknowns(val)) {\n                return undefined;\n            }\n            return val;\n        });\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __getAwaitableValue(__0) {\n  return (function() {\n    with({ exports: require(\"@pulumi/pulumi/output.js\"), getAwaitableValue: __getAwaitableValue }) {\n\nreturn function /*getAwaitableValue*/(v) {\n    if (exports.Output.isInstance(v)) {\n        return v.promise(/* withUnknowns */ true);\n    }\n    else {\n        return v;\n    }\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __isSecret(__0) {\n  return (function() {\n    with({ exports: require(\"@pulumi/pulumi/output.js\"), isSecret: __isSecret }) {\n\nreturn function /*isSecret*/(val) {\n    return exports.Output.isInstance(val.isSecret) ? Promise.resolve(false) : val.isSecret;\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __isSecretOutput(__0) {\n  return (function() {\n    with({ isSecret: __isSecret, isSecretOutput: __isSecretOutput }) {\n\nreturn function /*isSecretOutput*/(o) {\n    return isSecret(o);\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __getResourcesAndDetails(__0) {\n  return (function() {\n    with({ exports: require(\"@pulumi/pulumi/output.js\"), isSecretOutput: __isSecretOutput, getResourcesAndDetails: __getResourcesAndDetails }) {\n\nreturn function /*getResourcesAndDetails*/(allValues) {\n    const syncResources = new Set();\n    const allOutputs = [];\n    for (const v of allValues) {\n        if (exports.Output.isInstance(v)) {\n            allOutputs.push(v);\n            for (const res of v.resources()) {\n                syncResources.add(res);\n            }\n        }\n    }\n    // All the outputs were generated in `function all` using `output(v)`.  So it's safe\n    // to call `.allResources!` here.\n    const allResources = Promise.all(allOutputs.map(o =\u003e o.allResources())).then(arr =\u003e {\n        const result = new Set();\n        for (const set of arr) {\n            for (const res of set) {\n                result.add(res);\n            }\n        }\n        return result;\n    });\n    // A merged output is known if all of its inputs are known.\n    const isKnown = Promise.all(allOutputs.map(o =\u003e o.isKnown)).then(ps =\u003e ps.every(b =\u003e b));\n    // A merged output is secret if any of its inputs are secret.\n    const isSecret = Promise.all(allOutputs.map(o =\u003e isSecretOutput(o))).then(ps =\u003e ps.some(b =\u003e b));\n    return [syncResources, isKnown, isSecret, allResources];\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __getPromisedObject(__0) {\n  return (function() {\n    with({ __awaiter: __f2, getAwaitableValue: __getAwaitableValue, getPromisedObject: __getPromisedObject }) {\n\nreturn function /*getPromisedObject*/(keysAndOutputs) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const result = {};\n        for (const kvp of keysAndOutputs) {\n            result[kvp.key] = yield getAwaitableValue(kvp.value);\n        }\n        return result;\n    });\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __outputRec(__0) {\n  return (function() {\n    with({ resource_1: require(\"@pulumi/pulumi/resource.js\"), isUnknown: __isUnknown, createSimpleOutput: __createSimpleOutput, exports: require(\"@pulumi/pulumi/output.js\"), getAllResources: __getAllResources, OutputImpl: __f5, getAwaitableValue: __getAwaitableValue, getResourcesAndDetails: __getResourcesAndDetails, getPromisedObject: __getPromisedObject, outputRec: __outputRec }) {\n\nreturn function /*outputRec*/(val) {\n    if (val === null || typeof val !== \"object\") {\n        // strings, numbers, booleans, functions, symbols, undefineds, nulls are all returned as\n        // themselves.  They are always 'known' (i.e. we can safely 'apply' off of them even during\n        // preview).\n        return val;\n    }\n    else if (resource_1.Resource.isInstance(val)) {\n        // Don't unwrap Resources, there are existing codepaths that return Resources through\n        // Outputs and we want to preserve them as is when flattening.\n        return val;\n    }\n    else if (isUnknown(val)) {\n        return val;\n    }\n    else if (val instanceof Promise) {\n        // Recurse into the value the Promise points to.  This may end up producing a\n        // Promise\u003cOutput\u003e. Wrap this in another Output as the final result.  This Output's\n        // construction will be able to merge the inner Output's data with its own.  See\n        // liftInnerOutput for more details.\n        return createSimpleOutput(val.then(v =\u003e outputRec(v)));\n    }\n    else if (exports.Output.isInstance(val)) {\n        // We create a new output here from the raw pieces of the original output in order to\n        // accommodate outputs from downlevel SxS SDKs.  This ensures that within this package it is\n        // safe to assume the implementation of any Output returned by the `output` function.\n        //\n        // This includes:\n        // 1. that first-class unknowns are properly represented in the system: if this was a\n        //    downlevel output where val.isKnown resolves to false, this guarantees that the\n        //    returned output's promise resolves to unknown.\n        // 2. That the `isSecret` property is available.\n        // 3. That the `.allResources` is available.\n        const allResources = getAllResources(val);\n        const newOutput = new OutputImpl(val.resources(), val.promise(/*withUnknowns*/ true), val.isKnown, val.isSecret, allResources);\n        return newOutput.apply(outputRec, /*runWithUnknowns*/ true);\n    }\n    else if (val instanceof Array) {\n        const allValues = [];\n        let hasOutputs = false;\n        for (const v of val) {\n            const ev = outputRec(v);\n            allValues.push(ev);\n            if (exports.Output.isInstance(ev)) {\n                hasOutputs = true;\n            }\n        }\n        // If we didn't encounter any nested Outputs, we don't need to do anything.  We can just\n        // return this value as is.\n        if (!hasOutputs) {\n            // Note: we intentionally return 'allValues' here and not 'val'.  This ensures we get a\n            // copy.  This has been behavior we've had since the beginning and there may be subtle\n            // logic out there that depends on this that we would not want ot break.\n            return allValues;\n        }\n        // Otherwise, combine the data from all the outputs/non-outputs to one final output.\n        const promisedArray = Promise.all(allValues.map(v =\u003e getAwaitableValue(v)));\n        const [syncResources, isKnown, isSecret, allResources] = getResourcesAndDetails(allValues);\n        return new exports.Output(syncResources, promisedArray, isKnown, isSecret, allResources);\n    }\n    else {\n        const promisedValues = [];\n        let hasOutputs = false;\n        for (const k of Object.keys(val)) {\n            const ev = outputRec(val[k]);\n            promisedValues.push({ key: k, value: ev });\n            if (exports.Output.isInstance(ev)) {\n                hasOutputs = true;\n            }\n        }\n        if (!hasOutputs) {\n            // Note: we intentionally return a new value here and not 'val'.  This ensures we get a\n            // copy.  This has been behavior we've had since the beginning and there may be subtle\n            // logic out there that depends on this that we would not want ot break.\n            return promisedValues.reduce((o, kvp) =\u003e { o[kvp.key] = kvp.value; return o; }, {});\n        }\n        const promisedObject = getPromisedObject(promisedValues);\n        const [syncResources, isKnown, isSecret, allResources] = getResourcesAndDetails(promisedValues.map(kvp =\u003e kvp.value));\n        return new exports.Output(syncResources, promisedObject, isKnown, isSecret, allResources);\n    }\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __output(__0) {\n  return (function() {\n    with({ outputRec: __outputRec, exports: require(\"@pulumi/pulumi/output.js\"), createSimpleOutput: __createSimpleOutput, output: __output }) {\n\nreturn function /*output*/(val) {\n    const ov = outputRec(val);\n    return exports.Output.isInstance(ov) ? ov : createSimpleOutput(ov);\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __secret(__0) {\n  return (function() {\n    with({ output: __output, exports: require(\"@pulumi/pulumi/output.js\"), secret: __secret }) {\n\nreturn function /*secret*/(val) {\n    const o = output(val);\n    // we called `output` right above this, so it's safe to call `.allResources` on the result.\n    return new exports.Output(o.resources(), o.promise(/*withUnknowns*/ true), o.isKnown, Promise.resolve(true), o.allResources());\n};\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f1(__0) {\n  return (function() {\n    with({ __awaiter: __f2, assert: require(\"assert\"), pulumi: __pulumi }) {\n\nreturn function /*create*/(inputs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(Object.keys(inputs));\n            assert(inputs.owner);\n            return { id: \"123\", outs: { lol: pulumi.secret(inputs.owner) } };\n        });\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f11(__0, __1) {\n  return (function() {\n    with({ __awaiter: __f2, assert: require(\"assert\") }) {\n\nreturn function /*delete*/(id, props) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(Object.keys(props));\n            assert(props.owner);\n        });\n    };\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n\nfunction __f0() {\n  return (function() {\n    with({ provider: __provider }) {\n\nreturn () =\u003e provider;\n\n    }\n  }).apply(undefined, undefined).apply(this, arguments);\n}\n"
                },
                "parent": "urn:pulumi:dev::dynamic-provider-bug::pulumi:pulumi:Stack::dynamic-provider-bug-dev",
                "provider": "urn:pulumi:dev::dynamic-provider-bug::pulumi:providers:pulumi-nodejs::default::7a325861-2010-49ad-92e0-c189973c8615",
                "propertyDependencies": {
                    "__provider": null,
                    "owner": null
                },
                "sequenceNumber": 1
            }
        ]
    }
}
